// pipeline {
//     agent any

//     environment {
//         PATH = "${env.HOME}/bin:${env.PATH}" 
//     }

//     parameters {
//         string(name: 'IBM_API_KEY', defaultValue: '', description: 'IBM Cloud API key')
//         string(name: 'REPO_URL', defaultValue: '', description: 'Git repository URL for Terraform code')
//         string(name: 'TEAM_NAME', defaultValue: '', description: 'Enter the Team Name')
//         string(name: 'DB_NAME', defaultValue: '', description: 'Enter the Database Name')
//         string(name: 'MongoURL', defaultValue: '', description: 'Enter the Mongodb URL')
//         string(name: 'REQUESTED_CPU', defaultValue: '', description: 'Requested CPU')
//         string(name: 'REQUESTED_MEMORY', defaultValue: '', description: 'Requested Memory (GB)')
//     }

//     stages {

//         stage('Install Dependencies') {
//             steps {
//                 script {
//                     // Create a virtual environment
//                     sh 'python3 -m venv venv'
                    
//                     // Activate the virtual environment and install pymongo
//                     sh '''
//                         python3 -m venv venv
//                         . venv/bin/activate
//                         pip install --upgrade pip
//                         pip install "pymongo[srv]"
//                     '''
//                 }
//             }
//         }
//         stage('Install Terraform') {
//                     steps {
//                         script {
//                             sh '''
//                                 # Set the Terraform version
//                                 TERRAFORM_VERSION="1.5.0"  # Change this to the desired version

//                                 # Create a bin directory in the user's home directory
//                                 mkdir -p ${HOME}/bin

//                                 # Check if Terraform is already installed and is the correct version
//                                 if [ -f "${HOME}/bin/terraform" ]; then
//                                     CURRENT_VERSION=$(${HOME}/bin/terraform --version | head -n 1 | cut -d ' ' -f 2 | cut -d 'v' -f 2)
//                                     if [ "${CURRENT_VERSION}" == "${TERRAFORM_VERSION}" ]; then
//                                         echo "Terraform ${TERRAFORM_VERSION} is already installed."
//                                     else
//                                         echo "Updating Terraform to version ${TERRAFORM_VERSION}..."
//                                         # Download and install Terraform
//                                         cd ${HOME}/bin
//                                         wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
//                                         unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip  # Force overwrite
//                                         rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
//                                     fi
//                                 else
//                                     echo "Installing Terraform ${TERRAFORM_VERSION}..."
//                                     # Download and install Terraform
//                                     cd ${HOME}/bin
//                                     wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
//                                     unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip  # Force overwrite
//                                     rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
//                                 fi

//                                 # Add the bin directory to PATH
//                                 echo 'export PATH=${HOME}/bin:${PATH}' >> ${HOME}/.bashrc
//                                 source ${HOME}/.bashrc
//                             '''
//                         }
//                     }
//                 }

//              stage('Initialize Terraform Providers') {
//                  steps {
//                      script {
//                          sh '''
//                              # Navigate to the Terraform directory
//                              cd terraform-repo/ibm-cloud

//                               # Initialize Terraform (this will download the required providers)
//                              terraform init
//                          '''
//                      }
//                  }
//              }

//          stage('Terraform Plan') {
//              steps {
//                 script {
//                     sh '''
//                         # Navigate to the Terraform directory
//                         cd terraform-repo/ibm-cloud

//                         # Run terraform plan
//                         terraform plan
//                     '''
//                    }
//                  }
//                }
//              }


//         stage('Fetch Resource Allocation') {
//             steps {
//                 script {
//                     def teamName = params.TEAM_NAME
//                     def requestedCPU = params.REQUESTED_CPU.toInteger()
//                     def requestedMemory = params.REQUESTED_MEMORY.toInteger()
                    
//                     // Activate the virtual environment and run the Python script
//                     def fetchCommand = """
//                         . venv/bin/activate
//                         python3 ./manageiq-jobs/scripts/fetch_resources.py '${params.DB_NAME}' '${teamName}' '${params.MongoURL}'
//                     """
//                     def fetchOutput = sh(script: fetchCommand, returnStdout: true).trim()
                    
//                     echo "Fetch output: ${fetchOutput}"

//                     if (!fetchOutput?.trim()) {
//                         error "Error: Fetch output is empty. Check if the script executed correctly."
//                     }

//                     // Parse JSON output from Python script
//                     def resourceData = readJSON(text: fetchOutput)

//                     if (resourceData.containsKey('error')) {
//                         error "Error: ${resourceData.error}"
//                     }
                    
//                     def allocatedCPU = resourceData.allocated_cpu.toInteger()
//                     def allocatedMemory = resourceData.allocated_memory_gb.toInteger()

//                     // Compare Requested vs Allocated
//                     if (requestedCPU > allocatedCPU || requestedMemory > allocatedMemory) {
//                         error "Error: Requested resources exceed allocation! (Requested: ${requestedCPU} CPU, ${requestedMemory} GB RAM, Available: ${allocatedCPU} CPU, ${allocatedMemory} GB RAM)"
//                     }

//                     echo "Resources available. Proceeding with Terraform..."
//                 }
//             }
//         }

//         stage('Run Create Cluster Script') {
//             steps {
//                 script {
//                     sh """
//                     chmod +x ./manageiq-jobs/scripts/create-openshift-cluster.sh
//                     ./manageiq-jobs/scripts/create-openshift-cluster.sh --ibm-api-key ${IBM_API_KEY} --repo-url ${REPO_URL}
//                     """
//                 }
//             }
//         }

//     post {
//         success {
//             echo "Cluster creation completed successfully!"
//         }
//         failure {
//             echo "Cluster creation failed. Check the logs for details."
//         }
//     }
// }

pipeline {
    agent any

    parameters {
        string(name: 'IBM_API_KEY', defaultValue: '', description: 'IBM Cloud API key')
        string(name: 'REPO_URL', defaultValue: '', description: 'Git repository URL for Terraform code')
        string(name: 'TEAM_NAME', defaultValue: '', description: 'Enter the Team Name')
        string(name: 'DB_NAME', defaultValue: '', description: 'Enter the Database Name')
        string(name: 'MongoURL', defaultValue: '', description: 'Enter the Mongodb URL')
        string(name: 'REQUESTED_CPU', defaultValue: '', description: 'Requested CPU')
        string(name: 'REQUESTED_MEMORY', defaultValue: '', description: 'Requested Memory (GB)')
    }

    environment {
        PATH = "${env.HOME}/bin:${env.PATH}" 
    }

    stages {
        stage('Checkout Code') {
            steps {
                checkout scm
            }
        }

        stage('Clean Workspace') {
            steps {
                sh '''
                    echo "Cleaning up old files..."
                    rm -rf venv
                '''
            }
        }

        stage('Verify Python Installation') {
            steps {
                script {
                    sh '''
                        python3 --version
                        python3 -m pip list
                    '''
                }
            }
        }

    

        stage('Debug Workspace') {
            steps {
                sh '''
                    echo "Current directory: $(pwd)"
                    echo "Workspace: ${WORKSPACE}"
                    ls -lR
                '''
            }
        }

        stage('Fetch Resource Allocation') {
            steps {
                script {
                    def teamName = params.TEAM_NAME
                    def requestedCPU = params.REQUESTED_CPU.toInteger()
                    def requestedMemory = params.REQUESTED_MEMORY.toInteger()
                    
                    // Install pymongo if not already installed    
                    sh 'pip3 install --user pymongo'

                    // Fetch allocated resources using python3 directly
                    def fetchOutput = sh(
                        script: "python3 ./manageiq-jobs/scripts/fetch_resources.py '${params.DB_NAME}' '${teamName}' '${params.MongoURL}'",
                        returnStdout: true
                    ).trim()

                    echo "Fetch output: ${fetchOutput}"

                    // Check if fetchOutput is empty
                    if (!fetchOutput?.trim()) {
                        error "Error: Fetch output is empty. Check if the script executed correctly."
                    }

                    // Parse JSON output
                    try {
                        def resourceData = readJSON(text: fetchOutput)

                        // Debug JSON output
                        echo "Resource Data: ${resourceData}"
                        echo "Allocated CPU: ${resourceData.allocated_cpu}, Type: ${resourceData.allocated_cpu.getClass()}"
                        echo "Allocated Memory: ${resourceData.allocated_memory_gb}, Type: ${resourceData.allocated_memory_gb.getClass()}"

                        // Check for errors in the response
                        if (resourceData.containsKey('error')) {
                            error "Error: ${resourceData.error}"
                        }

                        // Validate and convert allocated_cpu and allocated_memory_gb
                        def allocatedCPU = resourceData.allocated_cpu
                        def allocatedMemory = resourceData.allocated_memory_gb

                        if (allocatedCPU == null || !allocatedCPU.toString().isNumber()) {
                            error "Error: allocated_cpu is not a valid number."
                        }
                        if (allocatedMemory == null || !allocatedMemory.toString().isNumber()) {
                            error "Error: allocated_memory_gb is not a valid number."
                        }

                        // Convert to integers
                        allocatedCPU = allocatedCPU.toInteger()
                        allocatedMemory = allocatedMemory.toInteger()

                        // Check if requested resources exceed allocated resources
                        if (requestedCPU > allocatedCPU || requestedMemory > allocatedMemory) {
                            echo "Requested resources exceed allocation! (Requested: ${requestedCPU} CPU, ${requestedMemory} GB RAM, Available: ${allocatedCPU} CPU, ${allocatedMemory} GB RAM)"
                            echo "Please delete existing clusters to free up resources."
                            currentBuild.result = 'UNSTABLE'
                            return
                        }

                        echo "Resources available. Proceeding with Terraform..."

                        // Store allocated resources in env for later stages (if needed)
                        env.ALLOCATED_CPU = allocatedCPU
                        env.ALLOCATED_MEMORY = allocatedMemory

                    } catch (Exception e) {
                        error "Error parsing JSON output: ${e.message}"
                    }
                }
            }
        }

        stage('Install Terraform') {
            steps {
                script {
                    sh '''
                        # Set the Terraform version
                        TERRAFORM_VERSION="1.5.0"  # Change this to the desired version

                        # Create a bin directory in the user's home directory
                        mkdir -p ${HOME}/bin

                        # Check if Terraform is already installed and is the correct version
                        if [ -f "${HOME}/bin/terraform" ]; then
                            CURRENT_VERSION=$(${HOME}/bin/terraform --version | head -n 1 | cut -d ' ' -f 2 | cut -d 'v' -f 2)
                            if [ "${CURRENT_VERSION}" == "${TERRAFORM_VERSION}" ]; then
                                echo "Terraform ${TERRAFORM_VERSION} is already installed."
                            else
                                echo "Updating Terraform to version ${TERRAFORM_VERSION}..."
                                # Download and install Terraform
                                cd ${HOME}/bin
                                wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                                unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip  # Force overwrite
                                rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                            fi
                        else
                            echo "Installing Terraform ${TERRAFORM_VERSION}..."
                            # Download and install Terraform
                            cd ${HOME}/bin
                            wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                            unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip  # Force overwrite
                            rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                        fi

                        # Add the bin directory to PATH
                        echo 'export PATH=${HOME}/bin:${PATH}' >> ${HOME}/.bashrc
                        source ${HOME}/.bashrc

                        # Verify installation
                        echo "PATH: ${PATH}"
                        which terraform
                        terraform --version
                    '''
                }
            }
        }

        stage('Initialize Terraform Providers') {
            steps {
                script {
                    sh '''
                        echo "Current directory: $(pwd)"
                        echo "Workspace: ${WORKSPACE}"
                        ls -lR
                        # Print the PATH for debugging
                        echo "PATH: ${PATH}"
                        # Navigate to the Terraform directory
                        cd terraform-repo/ibm-cloud

                        # Initialize Terraform (this will download the required providers)
                        terraform init
                    '''
                }
            }
        }

        stage('Run Create Cluster Script') {
            steps {
                script {
                    // Run the create cluster script
                    // sh """
                    // chmod +x ./manageiq-jobs/scripts/create-openshift-cluster.sh
                    // ./manageiq-jobs/scripts/create-openshift-cluster.sh --ibm-api-key ${IBM_API_KEY} --repo-url ${REPO_URL}
                    // """

                    // Subtract the requested resources from the allocated resources
                    def updatedCPU = env.ALLOCATED_CPU - params.REQUESTED_CPU.toInteger()
                    def updatedMemory = env.ALLOCATED_MEMORY - params.REQUESTED_MEMORY.toInteger()

                    def updateCommand = """
                        . venv/bin/activate
                        python3 ./manageiq-jobs/scripts/fetch_resources.py '${params.DB_NAME}' '${params.TEAM_NAME}' '${params.MongoURL}' update ${updatedCPU} ${updatedMemory}
                    """
                    def updateOutput = sh(script: updateCommand, returnStdout: true).trim()
                    echo "Update output: ${updateOutput}"

                    // Check for errors
                    def updateResult = readJSON(text: updateOutput)
                    if (updateResult.containsKey('error')) {
                        error "Error updating MongoDB: ${updateResult.error}"
                    } else {
                        echo "Successfully updated MongoDB: ${updateResult.success}"
                    }
                }
            }
        }
    }

    post {
        success {
            echo "Cluster creation completed successfully!"
        }
        failure {
            echo "Cluster creation failed. Check the logs for details."
        }
        unstable {
            echo "Requested resources exceed allocation. Please delete existing clusters to free up resources."
        }
    }
}